// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: movies.sql

package database

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addMovie = `-- name: AddMovie :one
INSERT INTO movies (
title,description,runtime,genre,age_rating,director,poster_url,release_date 
) VALUES ($1,$2,$3,$4,$5,$6,$7,$8)
RETURNING id, title, description, runtime, genre, age_rating, director, poster_url, release_date, created_at, updated_at, deleted_at
`

type AddMovieParams struct {
	Title       string      `json:"title"`
	Description string      `json:"description"`
	Runtime     int32       `json:"runtime"`
	Genre       string      `json:"genre"`
	AgeRating   string      `json:"age_rating"`
	Director    string      `json:"director"`
	PosterUrl   string      `json:"poster_url"`
	ReleaseDate pgtype.Date `json:"release_date"`
}

func (q *Queries) AddMovie(ctx context.Context, arg AddMovieParams) (Movie, error) {
	row := q.db.QueryRow(ctx, addMovie,
		arg.Title,
		arg.Description,
		arg.Runtime,
		arg.Genre,
		arg.AgeRating,
		arg.Director,
		arg.PosterUrl,
		arg.ReleaseDate,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Runtime,
		&i.Genre,
		&i.AgeRating,
		&i.Director,
		&i.PosterUrl,
		&i.ReleaseDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteMovie = `-- name: DeleteMovie :exec
UPDATE movies SET deleted_at=now() WHERE id=$1
`

func (q *Queries) DeleteMovie(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteMovie, id)
	return err
}

const getMovieById = `-- name: GetMovieById :one
SELECT id,title,description,runtime,genre,age_rating,director,poster_url,release_date
,created_at,updated_at
FROM movies 
WHERE id = $1 AND deleted_at IS NULL
`

type GetMovieByIdRow struct {
	ID          int64              `json:"id"`
	Title       string             `json:"title"`
	Description string             `json:"description"`
	Runtime     int32              `json:"runtime"`
	Genre       string             `json:"genre"`
	AgeRating   string             `json:"age_rating"`
	Director    string             `json:"director"`
	PosterUrl   string             `json:"poster_url"`
	ReleaseDate pgtype.Date        `json:"release_date"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetMovieById(ctx context.Context, id int64) (GetMovieByIdRow, error) {
	row := q.db.QueryRow(ctx, getMovieById, id)
	var i GetMovieByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Runtime,
		&i.Genre,
		&i.AgeRating,
		&i.Director,
		&i.PosterUrl,
		&i.ReleaseDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMovies = `-- name: GetMovies :many
SELECT id,title,description,runtime,genre,age_rating,director,poster_url,release_date
,created_at,updated_at
FROM movies 
WHERE  deleted_at IS NULL
ORDER BY release_date DESC 
LIMIT $1 OFFSET $2
`

type GetMoviesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetMoviesRow struct {
	ID          int64              `json:"id"`
	Title       string             `json:"title"`
	Description string             `json:"description"`
	Runtime     int32              `json:"runtime"`
	Genre       string             `json:"genre"`
	AgeRating   string             `json:"age_rating"`
	Director    string             `json:"director"`
	PosterUrl   string             `json:"poster_url"`
	ReleaseDate pgtype.Date        `json:"release_date"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetMovies(ctx context.Context, arg GetMoviesParams) ([]GetMoviesRow, error) {
	rows, err := q.db.Query(ctx, getMovies, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMoviesRow{}
	for rows.Next() {
		var i GetMoviesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Runtime,
			&i.Genre,
			&i.AgeRating,
			&i.Director,
			&i.PosterUrl,
			&i.ReleaseDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
